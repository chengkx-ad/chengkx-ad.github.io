[{"title":"IOC、AOP","url":"/posts/undefined/","content":"\n1、ioc 控制反转 管理对象 也可以说是DI Dependency injection 依赖注入\n\n- 开发模式\n\n  容器创建好对象-----> 程序使用\n\n​\t   程序不再负责对象的创建，而是直接使用IOC容器的对象\n\n```xml\n<bean class=\"spring.bean.Monster\" id=\"monster\">\n        <property name=\"monsterId\" value=\"01\"/>\n        <property name=\"name\" value=\"成成成\"/>\n        <property name=\"skill\" value=\"写代码\"/>\n</bean>\n每一组bean是一个对象\n```\n\n- 获取对象\n\n  ```java\n  @Test\n  public void get() {\n      ApplicationContext ioc = new ClassPathXmlApplicationContext(\"springXml.xml\");\n  \n      Object monster01 = ioc.getBean(\"monster\"); // 注意这里的monster01的类型 并不是Monster 可以强转 也可以像下面的方法一样  \n      System.out.println(monster01);\n  \n      // 指定类型\n      Monster monster = ioc.getBean(\"monster\", Monster.class);\n  }\n  ```\n\n- 实现spring容器  创建bean对象  保存至ioc中  读取\n\n  ```java\n  package spring.bean.applicationContext;\n  \n  import org.dom4j.Document;\n  import org.dom4j.DocumentException;\n  import org.dom4j.Element;\n  import org.dom4j.io.SAXReader;\n  import spring.bean.Monster;\n  \n  import java.util.List;\n  import java.util.concurrent.ConcurrentHashMap;\n  \n  public class Applicationcontext {\n  \n      private ConcurrentHashMap<String, Object> ioc = new ConcurrentHashMap<>();\n  \n      // Dom4j\n      public Applicationcontext(String iocXmlFile) throws DocumentException, ClassNotFoundException, InstantiationException, IllegalAccessException {\n  \n          // 类加载路径\n          String path = this.getClass().getResource(\"/\").getPath();\n  \n          // 获取解析器 读取xml文件\n          SAXReader saxReader = new SAXReader();\n          Document document = saxReader.read(path + iocXmlFile);\n          // 得到根节点  继而可以从根节点继续往下找\n          Element rootElement = document.getRootElement();\n  \n          // 得到第一个bean\n          Element bean = (Element)rootElement.elements(\"bean\").get(0);\n          // 获取这一组bean的id和class\n          String id = bean.attributeValue(\"id\");\n          String aClass = bean.attributeValue(\"class\");\n  \n          System.out.println(id);\n          System.out.println(aClass);\n  \n          // 获取这一组的所有property\n          List<Element> property = bean.elements(\"property\");\n  \n          //从这一组property中获取每个属性的值\n          int monsterID = Integer.parseInt(property.get(0).attributeValue(\"value\"));\n          String name = property.get(1).attributeValue(\"value\");\n          String skill = property.get(2).attributeValue(\"value\");\n  \n          System.out.println(monsterID);\n          System.out.println(name);\n          System.out.println(skill);\n  \n          // 通过反射创建bean实例，放入到ioc中\n          Class<?> aClass1 = Class.forName(aClass);\n  \n          Monster o = (Monster)aClass1.newInstance();\n  \n          o.setMonsterId(monsterID);\n          o.setName(name);\n          o.setSkill(skill);\n  \n          ioc.put(id, o);\n  \n      }\n      public Object getBean(String id) {\n          return ioc.get(id);\n      }\n  \n  }\n  ```\n\n- Spring管理bean-ioc\n\n  **通过id获取bean（前面的示例）**\n\n  **通过类型获取bean**\n\n  note：按类型获取beans，在配置文件中，同一类的bean只能有一个 否则会抛出异常NoUniqueBeanDefinitionException\n\n  应用场景：单例情况下会这么用  像是在某个线程下只需要一个对象实例\n\n  在容器的配置文件中为对象赋值，底层是通过setter方法完成的，所以我们要提供setter\n\n```java\nClassPathXmlApplicationContext ioc\n                = new ClassPathXmlApplicationContext(\"springXml.xml\");\n\n        Monster monster = ioc.getBean(Monster.class);\n        Monster2 monster2 = ioc.getBean(Monster2.class);\n```\n\n​\t\t**通过构造器配置bean**\n\n​\t\tconstructor-arg标签可以指定使用构造器的参数\n\n​\t\tindex表示构造器的第几个参数\n\n​\t\ttype表示在这个构造器中的参数类型，在一个javabean中不可能有两组type完全相同的构造器\n\n```xml\n<!--通过构造器获取bean-->\n    <bean id=\"monster03\" class=\"spring.bean.javabean01\">\n        <constructor-arg value=\"西游记\" index=\"0\"/>\n        <constructor-arg value=\"白骨精\" index=\"1\"/>\n        <constructor-arg value=\"九阴白骨爪\" index=\"2\"/>\n    </bean>\n    <!--通过type指定，因为在构造器中不可能存在同一组相同的类型-->\n    <bean id=\"monster04\" class=\"spring.bean.javabean01\">\n        <constructor-arg value=\"西游记\" type=\"java.lang.String\"/>\n        <constructor-arg value=\"白骨精\" type=\"java.lang.String\"/>\n        <constructor-arg value=\"九阴白骨爪\" type=\"java.lang.String\"/>\n    </bean>\n```\n\n​\t\t**通过p名称空间配置bean**\n\n```xml\n<bean id=\"bean01\" class=\"spring.bean.javabean01\"\n        p:movie=\"西游记\"\n        p:name=\"孙悟空\"\n        p:action=\"筋斗云\"\n    />\n```\n\n​\t\t**通过引用/注入的方式 通过ref可以实现相互引用**\n\n```xml\n<!--在daoImpl中没有任何属性-->\n    <bean id=\"dao\" class=\"spring.bean.daoImpl\"/>\n    <!--通过ref实现bean之间的相互引用-->\n    <bean id=\"service\" class=\"spring.bean.serviceImpl\">\n        <property name=\"dao\" ref=\"dao\"/>\n    </bean>\n```\n\n","categories":[],"tags":["java"]},{"title":"Hello World","url":"/posts/undefined/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","categories":[],"tags":[]}]